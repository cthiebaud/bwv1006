"""
svg_extract_note_heads.py

SVG Musical Notehead Extraction Pipeline  
========================================

This script extracts notehead positions and pitch information from SVG files
generated by LilyPond music notation software. It creates a dataset mapping
visual notehead locations to their corresponding musical pitches for use in
animated score following applications.

Process Overview:
1. Parse LilyPond-generated SVG to find clickable notehead elements
2. Extract pitch information from LilyPond source code via href links  
3. Determine visual coordinates for each notehead
4. Create sorted dataset ordered by visual appearance (left-to-right, top-to-bottom)

Input Files:
- SVG file with embedded LilyPond cross-references
- Original LilyPond (.ly) source file for pitch extraction

Output:
- CSV file with notehead coordinates, pitches, and reference links
"""

import re
import csv
import xml.etree.ElementTree as ET

# =============================================================================
# CONFIGURATION
# =============================================================================

SVG_FILE = "bwv1006_ly_one_line.svg"     # LilyPond-generated SVG with noteheads
LY_FILE = "bwv1006.ly"                   # Original LilyPond source code
OUTPUT_CSV = "bwv1006_csv_svg_note_heads.csv"  # Output dataset

print(f"üéº Processing musical score:")
print(f"   üìÑ SVG source: {SVG_FILE}")
print(f"   üéµ LilyPond source: {LY_FILE}")

# =============================================================================
# XML NAMESPACE SETUP
# =============================================================================

# SVG files use XML namespaces - we need to register these for proper parsing
NAMESPACES = {
    'svg': 'http://www.w3.org/2000/svg',        # Standard SVG namespace
    'xlink': 'http://www.w3.org/1999/xlink'     # XLink namespace for href attributes
}

# =============================================================================
# LILYPOND PITCH PATTERN MATCHING
# =============================================================================

# Regular expression to identify LilyPond note syntax in source code
# Matches: letter name + optional accidentals + optional octave marks
note_pattern = re.compile(r"""
    ^                    # Start of string (anchored match)
    ([a-g])             # Pitch letter: a, b, c, d, e, f, g
    (isis|eses|is|es)?  # Optional accidentals:
                        #   isis = double sharp (##)
                        #   eses = double flat (bb)  
                        #   is = sharp (#)
                        #   es = flat (b)
    \s*                 # Optional whitespace
    [,']*               # Optional octave marks:
                        #   ' = octave up
                        #   , = octave down
""", re.VERBOSE)

# =============================================================================
# LILYPOND SOURCE CODE PARSING
# =============================================================================

def extract_text_from_href(href_url):
    """
    Extract LilyPond pitch notation from cross-reference URLs.
    
    LilyPond embeds "textedit" URLs in SVG that point back to specific
    locations in the source .ly file. These URLs encode file path, line
    number, and column position, allowing us to extract the exact pitch
    notation that generated each visual notehead.
    
    Args:
        href_url (str): TextEdit URL from SVG (e.g., "textedit:///work/file.ly:25:10")
        
    Returns:
        str or None: LilyPond pitch notation (e.g., "cis'") or None if not found
        
    URL Format: textedit:///work/filepath:line:column
    - filepath: Path to .ly source file
    - line: 1-based line number  
    - column: 1-based character position
    """
    
    try:
        # Clean up URL format variations
        cleaned_href = href_url
        if cleaned_href.startswith("textedit:///work/"):
            cleaned_href = cleaned_href[len("textedit:///work/"):]
        else:
            return "(invalid href format)"

        # Parse URL components: "file.ly:line:column"
        url_parts = cleaned_href.split(":")
        if len(url_parts) < 3:
            return "(malformed URL)"
            
        file_path = url_parts[0]
        line_number = int(url_parts[1]) - 1    # Convert to 0-based indexing
        column_start = int(url_parts[2])       # 1-based column position

        # Read the LilyPond source file
        with open(file_path, encoding="utf-8") as source_file:
            source_lines = source_file.readlines()

        if line_number >= len(source_lines):
            return "(line number out of range)"

        # Extract text from the specified position to end of line
        target_line = source_lines[line_number]
        text_fragment = target_line[column_start:].strip()
        
        # Clean up common LilyPond syntax artifacts
        cleaned_text = text_fragment.strip("[]<>()")
        
        # Attempt to match LilyPond note pattern
        pattern_match = note_pattern.match(cleaned_text)
        
        if pattern_match:
            # Return the matched note notation without extra whitespace
            return pattern_match.group(0).replace(" ", "")
        else:
            # Return None if no valid note pattern found
            return None

    except Exception as parsing_error:
        return f"(error: {parsing_error})"

# =============================================================================
# SVG PARSING AND DATA EXTRACTION
# =============================================================================

print("üîç Loading and parsing SVG file...")

# Load SVG file and LilyPond source
with open(SVG_FILE, encoding="utf-8") as svg_file:
    svg_tree = ET.parse(svg_file)

with open(LY_FILE, encoding="utf-8") as ly_file:
    lilypond_lines = ly_file.readlines()

svg_root = svg_tree.getroot()

print("üìç Extracting notehead positions and pitch data...")

# =============================================================================
# NOTEHEAD DISCOVERY AND COORDINATE EXTRACTION
# =============================================================================

# Storage for discovered noteheads
notehead_data = []
processed_count = 0
valid_noteheads = 0

# Find all clickable <a> elements (these contain the noteheads)
for anchor_element in svg_root.findall(".//svg:a", NAMESPACES):
    processed_count += 1
    
    # Get the cross-reference URL
    href_attribute = anchor_element.get(f"{{{NAMESPACES['xlink']}}}href")
    if not href_attribute:
        continue
    
    # Extract pitch information from the href
    pitch_snippet = extract_text_from_href(href_attribute)
    
    # Skip if we couldn't extract valid pitch information
    if pitch_snippet is None:
        continue
    
    # Find the graphical group element containing visual positioning
    graphics_group = anchor_element.find("svg:g", NAMESPACES)
    if graphics_group is None:
        print(f"‚ö†Ô∏è  Warning: No graphics group found for href: {href_attribute}")
        continue
    
    # Extract coordinate transformation from the group's transform attribute
    transform_attribute = graphics_group.attrib.get("transform", "")
    
    # Parse translation coordinates: "translate(x, y)" or "translate(x,y)"
    coordinate_match = re.search(r"translate\(([-\d.]+)[ ,]+([-\d.]+)", transform_attribute)
    if not coordinate_match:
        print(f"‚ö†Ô∏è  Warning: No valid transform found for href: {href_attribute}")
        continue
    
    # Extract and convert coordinates
    x_coordinate = float(coordinate_match.group(1))
    y_coordinate = float(coordinate_match.group(2))
    
    # Store the notehead information
    notehead_data.append({
        "x": x_coordinate,
        "y": y_coordinate,
        "href": href_attribute,
        "snippet": pitch_snippet
    })
    
    valid_noteheads += 1

print(f"   üìä Processed {processed_count} anchor elements")