#!/usr/bin/env python3
"""
svg_optimize.py

SVG Optimization Pipeline for Musical Scores
============================================

This script optimizes SVG files generated by LilyPond music notation software
using SVGO (SVG Optimizer), while preserving critical musical notation attributes
required for interactive score applications.

Key Features:
- Reduces file size through path optimization and cleanup
- Preserves musical hyperlinks and cross-references  
- Maintains coordinate accuracy for animation systems
- Uses custom SVGO configuration for music notation compatibility
- Provides detailed optimization statistics

Requirements:
- Node.js and npm installed
- SVGO package available via npx
- Custom svgo.config.js file with music-specific settings

Usage:
    python svg_optimize.py [input_files...]
    python svg_optimize.py  # Uses default file list
"""

import subprocess
import shutil
from pathlib import Path
import sys

# =============================================================================
# OPTIMIZATION ENGINE
# =============================================================================

def optimize_svg(input_file, output_file=None):
    """
    Optimize an SVG file using SVGO with music notation-specific settings.
    
    This function runs SVGO optimization while preserving elements critical
    for musical score applications, including cross-reference links, precise
    coordinates, and interactive elements needed for score following.
    
    Args:
        input_file (str): Path to input SVG file
        output_file (str, optional): Path for optimized output file.
                                   If None, creates filename_optimized.svg
                                   
    Returns:
        bool: True if optimization succeeded, False otherwise
        
    Optimization Process:
    1. Validates input file exists and is accessible
    2. Runs SVGO with custom configuration for music notation
    3. Calculates size reduction and reports statistics
    4. Preserves all musical semantics while reducing file size
    """
    
    print(f"🎼 Starting optimization: {input_file}")
    
    # =================================================================
    # INPUT VALIDATION
    # =================================================================
    
    input_path = Path(input_file)
    if not input_path.exists():
        print(f"❌ Error: Input file '{input_file}' not found")
        return False
    
    if not input_path.is_file():
        print(f"❌ Error: '{input_file}' is not a regular file")
        return False
    
    # =================================================================
    # OUTPUT PATH CONFIGURATION
    # =================================================================
    
    # Generate output filename if not specified
    if output_file is None:
        # Create descriptive filename: original_optimized.svg
        output_file = input_path.stem + "_optimized" + input_path.suffix
    
    output_path = Path(output_file)
    
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # =================================================================
    # SVGO OPTIMIZATION EXECUTION
    # =================================================================
    
    try:
        print(f"   🔧 Running SVGO optimization...")
        
        # Build SVGO command with music-specific configuration
        # --config: Uses custom configuration preserving musical elements
        # -o: Specifies output path
        optimization_command = [
            "npx", "svgo",                        # Node package runner + SVGO
            "--config=svgo.config.js",            # Custom config for music notation
            str(input_path),                      # Input file path
            "-o", str(output_path)                # Output file path
        ]
        
        # Execute optimization with output capture for error handling
        result = subprocess.run(
            optimization_command, 
            capture_output=True, 
            text=True,
            timeout=60  # Prevent hanging on large files
        )
        
        # =============================================================
        # RESULT PROCESSING AND STATISTICS
        # =============================================================
        
        if result.returncode == 0:
            # Successful optimization - calculate metrics
            original_size = input_path.stat().st_size
            optimized_size = output_path.stat().st_size
            
            # Calculate size reduction percentage
            if original_size > 0:
                size_reduction = ((original_size - optimized_size) / original_size) * 100
            else:
                size_reduction = 0
            
            # Format file sizes with thousands separators for readability
            original_formatted = f"{original_size:,}"
            optimized_formatted = f"{optimized_size:,}"
            
            print(f"✅ Optimization successful!")
            print(f"   📁 Output: {output_file}")
            print(f"   📊 Size: {original_formatted} → {optimized_formatted} bytes")
            print(f"   💾 Reduction: {size_reduction:.1f}%")
            
            # Additional validation
            if optimized_size == 0:
                print(f"⚠️  Warning: Output file is empty - optimization may have failed")
                return False
                
            return True
            
        else:
            # Optimization failed - report error details
            print(f"❌ SVGO optimization failed!")
            print(f"   Return code: {result.returncode}")
            if result.stderr:
                print(f"   Error details: {result.stderr.strip()}")
            if result.stdout:
                print(f"   SVGO output: {result.stdout.strip()}")
            return False
            
    except subprocess.TimeoutExpired:
        print(f"❌ Optimization timed out after 60 seconds")
        return False
        
    except FileNotFoundError:
        print(f"❌ Error: SVGO not found. Please install with: npm install -g svgo")
        return False
        
    except Exception as optimization_error:
        print(f"❌ Unexpected error during optimization: {optimization_error}")
        return False

# =============================================================================
# BATCH PROCESSING AND CLI INTERFACE
# =============================================================================

if __name__ == "__main__":
    print("🚀 SVG Optimization Pipeline for Musical Scores")
    print("=" * 55)
    
    # =================================================================
    # FILE SELECTION LOGIC
    # =================================================================
    
    # Default files to optimize if no command line arguments provided
    default_files = [
        "bwv1006_svg_no_hrefs_in_tabs_bounded.svg"
        # Add more default files here as needed
    ]
    
    # Use command line arguments if provided, otherwise use defaults
    if len(sys.argv) > 1:
        files_to_process = sys.argv[1:]
        print(f"📋 Processing {len(files_to_process)} files from command line")
    else:
        files_to_process = default_files
        print(f"📋 Processing {len(files_to_process)} default files")
    
    # Display file list
    for i, filename in enumerate(files_to_process, 1):
        print(f"   {i}. {filename}")
    
    print()  # Blank line for readability
    
    # =================================================================
    # BATCH OPTIMIZATION EXECUTION
    # =================================================================
    
    successful_optimizations = 0
    total_original_size = 0
    total_optimized_size = 0
    
    for file_path in files_to_process:
        print(f"Processing file {successful_optimizations + 1}/{len(files_to_process)}")
        
        # Track file sizes for aggregate statistics
        input_path = Path(file_path)
        if input_path.exists():
            total_original_size += input_path.stat().st_size
        
        # Perform optimization
        if optimize_svg(file_path):
            successful_optimizations += 1
            
            # Add optimized file size to total
            output_path = Path(input_path.stem + "_optimized" + input_path.suffix)
            if output_path.exists():
                total_optimized_size += output_path.stat().st_size
        
        print()  # Blank line between files
    
    # =================================================================
    # BATCH COMPLETION SUMMARY
    # =================================================================
    
    print("=" * 55)
    print(f"🎯 Batch Optimization Complete")
    print(f"   ✅ Successfully optimized: {successful_optimizations}/{len(files_to_process)} files")
    
    if successful_optimizations > 0:
        # Calculate aggregate statistics
        total_reduction = 0
        if total_original_size > 0:
            total_reduction = ((total_original_size - total_optimized_size) / total_original_size) * 100
        
        print(f"   📊 Total size reduction: {total_original_size:,} → {total_optimized_size:,} bytes")
        print(f"   💾 Overall space saved: {total_reduction:.1f}%")
        
        if successful_optimizations == len(files_to_process):
            print(f"   🎉 All files optimized successfully!")
        else:
            failed_count = len(files_to_process) - successful_optimizations
            print(f"   ⚠️  {failed_count} files failed optimization")
    
    # Exit with appropriate code for scripting
    sys.exit(0 if successful_optimizations > 0 else 1)